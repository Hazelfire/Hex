<!DOCTYPE html>
<html>

	<head>
		<style>
			body {
				margin-left: 20%;
			}

			code {
				background-color: #EEEEEE;
				font-family: "Courier New", Courier, monospace;
			}

			li {
				padding-bottom: 20px;
			}
		</style>
	</head>

	<body>
		<p>
			<h1>HEX TUTORIAL</h1>
			Welcome to HEX<br>
			<br>
			Lets Get straight in,<br>
			HEX is a board game where the aim<br>
			is to draw a line to connect<br>
			the two sides of the board.<br>
			RED (player 1) draws a horizontal<br>
			line while BLUE (player 2) draws<br>
			a vertical line.<br>
			<br>
			The Difference in HEX is that<br>
			YOU can't interact with the board<br>
			except by writing a program to think<br>
			for you.<br>
			<br>
			The game asks the question:<br>
			<br>
			"Which hex do you want to take?"<br>
			<br>
			and you specify an X value<br>
			and a Y value of the hex you want<br>
			to take, like this:<br>
			<br>
			<code>return hex(X,Y);</code><br>
			<br>
			For Instance if i wanted to<br>
			choose the position 4,6:<br>
			<br>
			<code>return hex(4,6);</code><br>
			<br>
			And the rest of your program<br>
			is deciding which one to choose.<br>
			<br>
			This Tutorial assumes basic knowledge<br>
			of the Javascript language, there is<br>
			a good tutorial <a href="https://goo.gl/45Qhl0">here</a><br>
			(start at the "language basics" section.)<br>
			<br>
			<br>
			Lets have a quick look at the default HEX program<br>
			<code><br>

var properties = { <br>
	name: "Player 1", <br>
	author: "Me", <br>
	description: "New Bot, its very cool.", <br>
	version: 1.0 <br>
} <br>
 <br>
 <br>
function init (){ <br>
 <br>
} <br>
 <br>
function main (){ <br>
	let x = rndg(); <br>
	let y = rndg(); <br>
	return hex(x, y); <br>
} <br>
			</code><br>
			<br>
			The code has 3 parts, at the top you can define the AI's "properties"<br>
			like name, author, version and description, which are shown when the bot is used.<br>
			This is a standard JS object.
			<br>
			The init function is also defined which is the code that is run at the start of the game <br>
			before the ai starts playing. This is useful for writing code that initializes variables that you <br>
			would like to use later. <br>
			<br>
			Finally, there is the main function which is called every time it is the AI's turn. <br>
			<br>
			The main function needs to returns a hex. As shown above, this is done with <code>return hex(x,y);</code><br>
			where <code>x</code> and <code>y</code> are the coordinates of the selected hex.<br>
			<br>
			In hex, you play on an 11x11 board. The coordinates go from (0,0) in the top left to <br>
			(10, 10) in the bottom right. Notice how the coordinates start from 0, not 1. <br>
			<br>
			The code here defines two variables, <code>x</code> and <code>y</code>.<br>
			It defines them to be the result of the function <code>rndg()</code> which returns<br>
			a random number from zero to the grid size minus one, that is, a random number from 0 to 10.<br>
			The code then returns the chosen hex, that piece is taken and then it is the other player's turn<br>
			<br>
			<h1>BOT VARIABLE OBJECTS</h1>
			When the bot code is run, it is bound to a play object. For this reason you can use <code>this.</code> before variables
			in order to use them later. For instance <code>this.a = 1</code> stores an <code>a</code> variable on the player object.
			variables that you want to use again when the code is rerun must be placed on a player object. <i>note: in Coffeescript
			you can use <code>@</code> as an alias for <code>this.</code>, i.e <code>@a = 1</code></i>.
			<h1>HASH PARAMS</h1>
			In hex you write your code in Javascript, but you can also write it<br>
			in <a href="http://Coffeescript.org">CoffeeScript</a>. In order to do this,<br>
			you must put <code>#COFFEE</code> at the start of your program.<br>
			Other hash parameters you can set are listed below.<br>
			<ul>
				<li><strong><code>#COFFEE or #COFFEESCRIPT</code></strong><br>Compile code as coffeescript.<br>
					Note that the structures such as props and event definitions are also compiled.</li>
				<li><strong><code>#LATTE or #TIPPYTOE</code></strong><br>Pre-compile code as pythonic coffeescript (or lattescript or tipPYToe).</li>
				<li><strong><code>#MATHS</code></strong><br>Releases maths objects to global namespace i.e use <code>round(x)</code> instead of <code>Math.round(x)</code>.</li>
			</ul>
			<h1>GLOBAL VARIABLES</h1>
			<ul>
				<li><strong><code>turn</code></strong><br>Returns who's turn, its either <code>PLAYER1</code> or <code>PLAYER2</code> (<code>0</code> or <code>1</code>)</li>
				<li><strong><code>turnCount</code></strong><br>Which turn we are on, increments for both players.</li>
				<li><strong><code>attemptCount</code></strong><br>How many times a hex has been returned for both players.</li>
				<li><strong><code>gridSize</code></strong><br>Returns size of grid. (11)</li>
				<li><strong><code>PLAYER1</code></strong><br>Player 1 value. e.g <code>turn == PLAYER1</code></li>
				<li><strong><code>PLAYER2</code></strong><br>Player 2 value. e.g <code>turn == PLAYER2</code></li>
				<li><strong><code>P1</code></strong><br>Player 1 value.</li>
				<li><strong><code>P2</code></strong><br>Player 2 value.</li>
				<li><strong><code>RED</code></strong><br>Player 1 value.</li>
				<li><strong><code>BLUE</code></strong><br>Player 2 value.</li>
				<li><strong><code>VAL_EMPTY</code></strong><br>Hex value that is empty. e.g <code>value(0, 0) == VAL_EMPTY</code></li>
				<li><strong><code>VAL_PLAYER1</code></strong><br>Hex value that is player 1. e.g <code>value(0, 0) == VAL_PLAYER1</code></li>
				<li><strong><code>VAL_PLAYER2</code></strong><br>Hex value that is player 2. e.g <code>value(0, 0) == VAL_PLAYER2</code></li>
				<li><strong><code>VAL_RED</code></strong><br>Hex value that is player 1.</li>
				<li><strong><code>VAL_BLUE</code></strong><br>Hex value that is player 2.</li>
				<li><strong><code>VAL_P1</code></strong><br>Hex value that is player 1.</li>
				<li><strong><code>VAL_P2</code></strong><br>Hex value that is player 2.</li>
			</ul>
			<h1>FUNCTIONS</h1>
			<ul>
				<li><strong><code>clamp(value, min, max)</code></strong><br>Returns a restricted value between min &amp; max.</li>
				<li><strong><code>rnd(x)</code></strong><br>Returns a value between 0 and x.</li>
				<li><strong><code>rndg()</code></strong><br>Returns a random grid integer.</li>
				<li><strong><code>round(value)</code></strong><br>Returns given value to the nearest integer.</li>
				<li><strong><code>hex(x, y)</code></strong><br> Returns info about hex in given position.</li>
				<li><strong><code>skip()</code></strong><br>Debug function - use <code>return skip();</code> to pass turn.</li>
				<li><strong><code>trace(x, y, colour)</code></strong><br>Sets highlighted hex to given position &amp; colour</li>
				<li><strong><code>empty(x, y)</code></strong><br>Returns whether given hex is not claimed</li>
				<li><strong><code>value(x, y)</code></strong><br>Returns the value of given hex, 0=empty, 1=red, 2=blue</li>
				<li><strong><code>colour(x, y)</code></strong><br>Returns the colour of given hex, either red, blue or blank (returned as a colour string)</li>
				<li><strong><code>neighbours(x, y, value/colour)</code></strong><br>Returns amount of neighbours a given hex has of a certain value or colour.</li>
				<li><strong><code>amount_in_row(y, value)</code></strong><br>Returns amount of hex's in a row with a certain value.</li>
				<li><strong><code>amount_in_column(x, value)</code></strong><br>Returns amount of hex's in a column with a certain value.</li>
				<li><strong><code>connected(x1, y1, x2, y2)</code></strong><br>Returns whether given hex's are neighbours.</li>
				<li><strong><code>isEdgeConnected(x, y, edge)</code></strong><br>Returns whether given hex is indirectly connected to the given edge.</li>
				<li><strong><code>list(func(hex))</code></strong><br>Returns a list of all hex's which meet the criteria defined by the <code>func</code></li>
				<li><strong><code>clone()</code></strong><br>Returns a copy of the game grid.</li>
				<li><strong><code>clone3d()</code></strong><br>Returns a copy of the games connections grid. You shouldn't have to do this.</li>
				<li><strong><code>will_win(cloned_board)</code></strong><br>Returns whether this board is in a winning state for the current player.</li>
				<li><strong><code>turn_will_win(x, y)</code></strong><br>Returns whether performing a move would win.</li>
				<li><strong><code>get_future(cloned_board)</code></strong><br>Returns the game state at the end of the turn. 0 = Continue, 1 = Player 1 will win, 2 = Player 2 will win</li>
				<li><strong><code>perform_move(cloned_board, x, y)</code></strong><br>Performs a move on a cloned board.</li>
				<li><strong><code>get_turn(count)</code></strong><br>Returns turn performed on <code>count</code> move. Negatives return previous turns i.e <code>get_turn(-1)</code> returns last move.</li>
				<li><strong><code>last_turn()</code></strong><br>Returns previous turn.</li>
				<li><strong><code>turn_position(turn object)</code></strong><br>Returns position that given turn captured. i.e <code>turn_position(get_turn(-1))</code> returns the position of the last turn.</li>
				<li><strong><code>turn_position_x(turn object)</code></strong><br>Returns x value of position that given turn captured.</li>
				<li><strong><code>turn_position_y(turn object)</code></strong><br>Returns y value of position that given turn captured.</li>
				<li><strong><code>turn_player(turn object)</code></strong><br>Returns which player performed set move. i.e <code>turn_player(get_turn(0))</code> returns which player had the first move (always red)</li>
			</ul>
		</p>
	</body>
</html>
