@name Bridge_Bot
@author Ewan_Breakey
@version 1.1
@desc
Draws a diagonal line then uses
an 'eval' method to choose moves
which give about 2-3 similiar
neighbours & 0-2 enemy neighbours
while also penalising for too many
similiar neighbours
@descend
@script
if (turnCount < 20) {
	//SET UP LINE
	var x = Math.round(turnCount/2);
	var y = Math.round(turnCount/2);
	var a = 64;
	while (a > 0 && !empty(x,y))
	{x += rnd(2)-1;y += rnd(2)-1;}
	return hex(x,y)	
}else{
	//FILL IN
	function evaluate(board,cboard)
	{
		var score = 0;
		for (var i=0;i<gridSize;i++)
		{
			for (var j=0;j<gridSize;j++)
			{
				//IF ITS OUR PEICE
				if (board[i][j] == turn+1)
				{
					//GET SCORE FOR BEING NEAR US
					score += neighbours_ext(i,j,red,board)+(neighbours_ext(i,j,blue,board)/2);
					score -= (neighbours_ext(i,j,red,board)>3)*2;
				}
			}
		}
		
		//IF WE DO THIS DO WE WIN?
		if (game_update_connections_ext(board,cboard,false) == turn+1) //MAKING SURE TO UNAUTHORIZE SO WE DON'T END THE GAME EARLY!
		{
			//THEN DO IT!
			score += 1000;
		}
		
		return score;
	}

	//GET ALL POSIBLE MOVES
	var moves = new Array();
	for (i=0;i<gridSize;i++)
	{
		for (j=0;j<gridSize;j++)
		{
			if (empty(i,j))
			{
				moves.push({x: i,y: j});
			}
		}
	}


	//CREATE ARRAY OF SCORES
	var scores = new Array();

	//CREATE WORKING COPY
	for (i=0;i<moves.length;i++)
	{
		var work = clone();
		var cwork = clone3d();
		work[moves[i].x][moves[i].y] = turn+1;
		scores.push(evaluate(work,cwork));
	}


	//CHOOSE MOVE BY LOOKING AT SCORES
	var best = -999;
	var bestI = 0;
	for (i=0;i<scores.length;i++)
	{
		if (scores[i] > best)
		{
			best = scores[i];
			bestI = i;
		}
	}

	return hex(moves[bestI].x,moves[bestI].y);
}
@scriptend